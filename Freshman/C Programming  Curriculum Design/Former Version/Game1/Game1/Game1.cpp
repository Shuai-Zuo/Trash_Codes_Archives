#include "pch.h"
#include <graphics.h>
#include <conio.h>
#include<math.h>
#include<stdio.h>
#include<stdlib.h>

#define WIDTH 1280 //resolution 1280x720
#define HEIGHT 720
#define PI 3.141592654
#define LINE (WIDTH*7/8)
#define BOTTONX1 (WIDTH*29/32)
#define BOTTONX2 (WIDTH*31/32)
//#define BOTTONY (HEIGHT/24)// (1/24 to 3/24) (5/24 to 7/24) (9/24 to 11/24)
#define BOTTONY (HEIGHT/32)// (1/32 to 3/32) (5/32 to 7/32) (9/32 to 11/32) (13/32 to 15/32)
#define BOTTONGAME WIDTH/320

typedef struct {
	char name[20];
	int score;
}USERDATA;

typedef struct {
	int x;
	int y;
}TARGET;

typedef struct targetnode{
	int x;
	int y;
	int cal;  //0 means +, 1 means -, 2 means *, 3 means /;    generated by rand()%4
	int answer;
	int q1;
	int q2;
	struct targetnode*next;
}TARNODE;

void init(USERDATA &user, IMAGE background, IMAGE target);//初始化界面
void displayButton();//初始化按钮
void ChangeButton(int*flagStart);//切换暂停与继续按钮
void targetmove(TARNODE*tarnod, IMAGE background, IMAGE target);//目标移动
TARNODE*create(TARNODE*f);//生成链表(非头) 输入链表尾部,返回新的链表尾部
TARNODE*createhead(); //生成链表头,返回链表头
void putlist(TARNODE*h, IMAGE target);//顺序检索链表,作putimage
void targetmove(TARNODE*tarnod, IMAGE background, IMAGE target);//绘图相关
int checkmouseposition_Botton(int mouseX, int mouseY);//检测鼠标坐标按钮 按钮区
int checkmouseposition_Game(int mouseX, int mouseY);//检测鼠标坐标按钮 游戏区
TARNODE*checkmouseposition_Target(int mouseX, int mouseY, TARNODE*h, int answer);//检测鼠标坐标按钮 目标
TARNODE*delete_out_of_bound_target(TARNODE*h);//清除出界目标
void freeAll(TARNODE*h);//清除全部链表
void reinitline(IMAGE background);//重新绘制边界线与背景
TARNODE*delete_on_target(TARNODE*d, TARNODE*h);


int main(void) {
	//Main Function
	USERDATA user;
	TARNODE*h = NULL, *f = NULL, *chk;
	IMAGE background, target;
	int mouseX, mouseY;
	int flag = -1, flagStart = -1,flagpause;
	int answer = -1;
	MOUSEMSG mmsg;
	h = createhead();
	f = h;
	loadimage(&background, "Image\\Background1280x720.png");
	loadimage(&target, "Image\\Mov.png");
	init(user, background, target);
	while (1)
	{
		if (MouseHit()) {
			mmsg = GetMouseMsg();
			switch (mmsg.uMsg) {
			case WM_LBUTTONDOWN:
				mouseX = mmsg.x;
				mouseY = mmsg.y; 

				if (mouseX > LINE && mouseX <= WIDTH && mouseY > 0 && mouseY <= HEIGHT / 2) {
					flagpause = flag;
					flag = checkmouseposition_Botton(mouseX, mouseY);
					if (flag == -1) {
						flag = flagpause;
					}
				}
				if (mouseX > BOTTONGAME * 63 && mouseX <= BOTTONGAME * 273 && mouseY > HEIGHT * 9 / 12 && mouseY <= HEIGHT * 11 / 12) {
					answer = checkmouseposition_Game(mouseX, mouseY);
				}
				if (mouseX > 0 && mouseX <= LINE && mouseY > 0 && mouseY <= HEIGHT * 9 / 12) {
					chk = checkmouseposition_Target(mouseX, mouseY, h, answer);
					if (chk != NULL)
						//h = delete_on_target(chk, h);
						;//TODO
						
				}

			}
		}
		if (flag == 1) {
			if (flagStart != 1) {
				if (flagStart != 0)
					flagStart = 0;
				if (h == NULL) {
					h = createhead();
					f = h;
				}
				if (f->x > LINE / 4)
					f = create(f);
				targetmove(h, background, target);
			}
		}
		if (flag == 2) {
			if (flagStart != -1) {
				ChangeButton(&flagStart);
				flag = 1;
			}
		}
		if (flag == 3) {
			//TODO
			freeAll(h);
			h = NULL;
			flag = 1;
		}
		if (flag == 4) {
			freeAll(h);
			exit(0);
		}
	}
}

void init(USERDATA &user, IMAGE background, IMAGE target)
{

	IMAGE target_img;
	initgraph(WIDTH, HEIGHT);  //界面大小
	setbkcolor(WHITE);         //背景色
	cleardevice();             //清屏
	putimage(0, 0, &background);
	setcolor(BLUE);             //线颜色
	setlinestyle(PS_SOLID, 2);
	rectangle(1, 1, WIDTH - 1, HEIGHT - 1);  //最外侧线
	line(LINE, 0, LINE, HEIGHT);
	line(LINE, HEIGHT / 2, WIDTH, HEIGHT / 2);
	displayButton();

	/*while (1)
	{
		BeginBatchDraw();//开始批量绘图
		putimage(0, 0, &background);
		mov_y =25 * sin(mov_x * (PI/(WIDTH/16*7)));
		//putpixel((int)mov_x, (int)mov_y + 200, BLACK);
		putimage(WIDTH * 7 / 8 - 180 - (int)mov_x, (int)mov_y + 25, &target);
		//	putimage(i, 100, &p1, SRCAND);
		//	putimage(i, 100, &p2, SRCINVERT);		
		EndBatchDraw();
		mov_x += 1;	
		Sleep(12);	//暂停
	
	}
	*/

	/*InputBox(user.name, 20, "请输入用户名：");
	outtextxy(WIDTH / 2 + 10, GAME_HEIGHT + 10, "Name: ");
	outtextxy(WIDTH / 2 + 60, GAME_HEIGHT + 10, user.name);

	displayDog(tar);*/
}

void displayButton()
{
	setfillcolor(RGB(128, 255, 255));

	setbkmode(TRANSPARENT);

	fillrectangle(BOTTONX1, BOTTONY, BOTTONX2, BOTTONY*3);
	outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 1 + BOTTONY * 3 / 4, "开 始");

	fillrectangle(BOTTONX1, BOTTONY * 5, BOTTONX2, BOTTONY * 7);
	outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 5 + BOTTONY * 3 / 4, "暂 停");

	fillrectangle(BOTTONX1, BOTTONY * 9, BOTTONX2, BOTTONY * 11);
	outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 9 + BOTTONY * 3 / 4, "删 除");

	fillrectangle(BOTTONX1, BOTTONY * 13, BOTTONX2, BOTTONY * 15);
	outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 13 + BOTTONY * 3 / 4, "退 出");

	fillrectangle(BOTTONGAME * 63, HEIGHT * 9 / 12, BOTTONGAME * 105, HEIGHT * 11 / 12);
	fillrectangle(BOTTONGAME * 119, HEIGHT * 9 / 12, BOTTONGAME * 161, HEIGHT * 11 / 12);
	fillrectangle(BOTTONGAME * 175, HEIGHT * 9 / 12, BOTTONGAME * 217, HEIGHT * 11 / 12);
	fillrectangle(BOTTONGAME * 231, HEIGHT * 9 / 12, BOTTONGAME * 273, HEIGHT * 11 / 12);


	//fillrectangle(100, GAME_HEIGHT + 10, 150, GAME_HEIGHT + 50);
	//outtextxy(110, GAME_HEIGHT + 20, "退出");
}

void ChangeButton(int*flagStart)
{
	static int flag = 0;
	setfillcolor(RGB(128, 255, 255));
	setbkmode(TRANSPARENT);
	clearrectangle(BOTTONX1, BOTTONY * 5, BOTTONX2, BOTTONY * 7);
	fillrectangle(BOTTONX1, BOTTONY * 5, BOTTONX2, BOTTONY * 7);
	if (flag == 0)
	{
		outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 5 + BOTTONY * 3 / 4, "继 续");
		flag = 1;
		*flagStart = 1;
	}
	else if (flag == 1)
	{
		outtextxy(BOTTONX1 * 59 / 58, BOTTONY * 5 + BOTTONY * 3 / 4, "暂 停");
		flag = 0;
		*flagStart = 0;
	}
}

void targetmove(TARNODE*tarnod,IMAGE background, IMAGE target) {
		//static float mov_x = 0, mov_y = 0;
		IMAGE target_img1 , target_img2;
		getimage(&target_img1, LINE, 0, WIDTH, HEIGHT);
		getimage(&target_img2, BOTTONGAME * 63, HEIGHT * 9 / 12, BOTTONGAME * 273, HEIGHT * 11 / 12);
		BeginBatchDraw();//开始批量绘图
		reinitline(background);
		putlist(tarnod, target);
		putimage(LINE, 0, &target_img1);
		putimage(BOTTONGAME * 63, HEIGHT * 9 / 12, &target_img2);
		//当牌子运动时，若曲线运动,可视为满足函数 y = Asin(ωx) ω= π/7S  s=Screen_x/16
		//mov_y = 25 * sin(mov_x * (PI / (WIDTH / 16 * 7)));
		//putpixel((int)mov_x, (int)mov_y + 200, BLACK);
		//putimage(WIDTH * 7 / 8 - 180 - (int)mov_x, (int)mov_y + 25, &target);
		//	putimage(i, 100, &p1, SRCAND);
		//	putimage(i, 100, &p2, SRCINVERT);		
		EndBatchDraw();
		
		//mov_x += 1;
}

TARNODE*create(TARNODE*f)
{
	TARNODE *p;
		p = (TARNODE*)malloc(sizeof(TARNODE));
		p->next = NULL;
		p->x = 0;
		p->y = 0;
		p->cal = rand() % 4;
		p->answer = rand() % 4 + 3;
		f->next = p;
		f = p;
	return f;
}

TARNODE*createhead()
{
	TARNODE *h;
	h = (TARNODE*)malloc(sizeof(TARNODE));
	h->next = NULL;
	h->cal = rand() % 4;
	h->x = 0;
	h->y = 0;
	h->answer = rand() % 4 + 3;
	return h;
}

void putlist(TARNODE*h, IMAGE target)
{
	TARNODE*p = NULL;
	delete_out_of_bound_target(h);
	p = h;
	while (p != NULL)
	{
		//当牌子运动时，若曲线运动,可视为满足函数 y = Asin(ωx) ω= π/7S  s=Screen_x/16
		p->y =(int) 25 * sin(p->x * (PI / (WIDTH / 16 * 7)));
		p->x += 1;
		putimage(WIDTH * 7 / 8 - p->x, p->y + 35, &target);
		p = p->next;
	}
}

int checkmouseposition_Botton(int mouseX, int mouseY)
{
	if(mouseX >= BOTTONX1 && mouseX <= BOTTONX2 && mouseY >= BOTTONY && mouseY <= BOTTONY * 3)
		return 1; //开始
	else if(mouseX >= BOTTONX1 && mouseX <= BOTTONX2 && mouseY >= BOTTONY * 5 && mouseY <= BOTTONY * 7)
		return 2; //暂停
	else if(mouseX >= BOTTONX1 && mouseX <= BOTTONX2 && mouseY >= BOTTONY * 9 && mouseY <= BOTTONY * 11)
		return 3; //删除
	else if(mouseX >= BOTTONX1 && mouseX <= BOTTONX2 && mouseY >= BOTTONY * 13 && mouseY <= BOTTONY * 15)
		return 4; //退出
	else
		return -1;	
}

int checkmouseposition_Game(int mouseX, int mouseY){
	if (mouseX >= BOTTONGAME * 63 && mouseX <= BOTTONGAME * 105 && mouseY >= HEIGHT * 9 / 12 && mouseY <= HEIGHT * 11 / 12)
		return 3; //3
	else if (mouseX >= BOTTONGAME * 119 && mouseX <= BOTTONGAME * 161 && mouseY >= HEIGHT * 9 / 12 && mouseY <= HEIGHT * 11 / 12)
		return 4; //4
	else if (mouseX >= BOTTONGAME * 175 && mouseX <= BOTTONGAME * 217 && mouseY >= HEIGHT * 9 / 12 && mouseY <= HEIGHT * 11 / 12)
		return 5; //5
	else if (mouseX >= BOTTONGAME * 231 && mouseX <= BOTTONGAME * 273 && mouseY >= HEIGHT * 9 / 12 && mouseY <= HEIGHT * 11 / 12)
		return 6; //6
	else
		return -1;
}

TARNODE*checkmouseposition_Target(int mouseX, int mouseY, TARNODE*h,int answer) {
	TARNODE*p = h;
	while (p != NULL)
	{
		if (mouseX >= p->x && mouseX <= p->x + 180 && mouseY >= p->y && mouseY <= p->y + 120/* && p->answer == answer*/)
			return p;
		p = p->next;
	}
		return NULL;
}

TARNODE*delete_out_of_bound_target(TARNODE*h) {
	TARNODE*p = NULL;
	if (h->x <= -180) {
		p = h;
		h = h->next;
		free(p);
	}
	return h;
}

void freeAll(TARNODE*h)
{
	TARNODE*p = h, *q;
	while (p != NULL)
	{
		q = p->next;
		free(p);
		p = q;
	}
}

void reinitline(IMAGE background) {
	putimage(0, 0, &background);
	line(LINE, 0, LINE, HEIGHT);
	rectangle(1, 1, WIDTH - 1, HEIGHT - 1);
}

TARNODE*delete_on_target(TARNODE*d, TARNODE*h)// bagguaru
{
	TARNODE*f, *p;
	if (h != NULL) {
		if (d == h) {
			h = h->next;
			free(d);
			return h;
		}
		else {
			f = h;
			p = f;
			while (f != d) {
				p = f;
				f = f->next;
			}
			f = f->next;
			free(d);
			p->next = f;
			return p;
		}
	}
}



//Reference

/*
#include<stdio.h>
#include<stdlib.h>
struct chain
{
	int data;
	struct chain *next;
};
struct chain*create();
struct chain*create2();
void output(struct chain*head);
int time(struct chain*head);
void free1(struct chain*head);
int main()
{
	int i;
	struct chain *p, *h;
	h = create2();
	p = h;
	output(h);
	printf("\n%d\n", time(h));
	free1(h);
}

struct chain*create()
{
	int i;
	struct chain *p, *f = NULL, *h = NULL;
	for (i = 1; i <= 10; i++)
	{
		p = (struct chain *)malloc(sizeof(struct chain));
		p->next = NULL;
		p->data = i;
		if (h == NULL)
		{
			h = p;
			f = p;
		}
		else
		{
			f->next = p;
			f = p;
		}
	}
	return h;
}

void output(struct chain*head)
{
	struct chain*p = head;
	while (p != NULL)
	{
		printf("%d ", p->data);
		p = p->next;
	}
}

struct chain*create2()
{
	int i;
	struct chain *p, *f = NULL, *h = NULL;
	for (i = 1; i <= 10; i++)
	{
		p = (struct chain *)malloc(sizeof(struct chain));
		p->data = i;
		p->next = h;
		h = p;
	}
	return h;
}

int time(struct chain*head)
{
	struct chain*p = head;
	int i = 0;
	while (p != NULL)
	{
		i++;
		p = p->next;
	}
	return i;
}

void free1(struct chain*head)
{
	struct chain*p = head, *q;
	while (p != NULL)
	{
		q = p->next;
		free(p);
		p = q;
	}
}

*/


/*
#define WIDTH 640
#define HEIGHT 480

#define GAME_HEIGHT (HEIGHT*5/6)

#define  UP    72
#define  DOWN  80
#define  LEFT  75
#define  RIGHT 77

typedef struct {
	char name[20];
	int score;
}USER;

typedef struct {
	int x;
	int y;
}TARGET;
typedef struct {
	int x; int y;
}APPLE;

void init(USER &user, TARGET tar);
void displayButton();
int checkButton(int mouseX, int mouseY);
void displayDog(TARGET tar);
void moveDog(TARGET &tar, int k);
void displayApple(APPLE apple);
void moveApple(APPLE &apple);
void gameOver();

int main()
{
	int mouseX;	        //鼠标位置坐标X
	int mouseY;
	MOUSEMSG mmsg;	    //鼠标消息变量

	USER user;
	TARGET tar = { 10,GAME_HEIGHT - 50 };
	APPLE apple = { 20,1 };

	int flag = -1;
	char c = 0;

	init(user, tar);   //初始化

	while (1) {

		//处理鼠标消息
		if (MouseHit()) {
			mmsg = GetMouseMsg();
			switch (mmsg.uMsg) {
			case WM_LBUTTONDOWN:
				mouseX = mmsg.x;
				mouseY = mmsg.y;    //取出鼠标x,y值

				//鼠标在按钮区
				if (mouseX > 0 && mouseX <= WIDTH / 2 && mouseY > GAME_HEIGHT && mouseY <= HEIGHT) {
					flag = checkButton(mouseX, mouseY);
				}
			}
		}
		if (_kbhit()) {
			if (_getch() == 0xE0)
				c = _getch();

			if (c == RIGHT) { moveDog(tar, 1); displayDog(tar); }
			if (c == LEFT) { moveDog(tar, -1); displayDog(tar); }
		}

		if (flag == 1) {
			displayApple(apple);
			moveApple(apple);
			Sleep(30);

		}
		else if (flag == 2)
			gameOver();
	}
	return 0;
}
void init(USER &user, TARGET tar)
{
	initgraph(WIDTH, HEIGHT);  //界面大小
	setbkcolor(WHITE);         //背景色
	cleardevice();             //清屏
	setcolor(RED);             //线颜色
	setlinestyle(PS_SOLID, 2);
	rectangle(1, 1, WIDTH - 1, HEIGHT - 1);  //最外侧线
	line(0, GAME_HEIGHT, WIDTH, GAME_HEIGHT);

	line(WIDTH / 2, GAME_HEIGHT, WIDTH / 2, HEIGHT);

	displayButton();

	InputBox(user.name, 20, "请输入用户名：");
	outtextxy(WIDTH / 2 + 10, GAME_HEIGHT + 10, "Name: ");
	outtextxy(WIDTH / 2 + 60, GAME_HEIGHT + 10, user.name);

	displayDog(tar);
}

void displayButton()
{
	setfillcolor(RGB(255, 255, 100));

	setbkmode(TRANSPARENT);

	fillrectangle(10, GAME_HEIGHT + 10, 70, GAME_HEIGHT + 50);
	outtextxy(15, GAME_HEIGHT + 20, "按钮1");

	fillrectangle(100, GAME_HEIGHT + 10, 150, GAME_HEIGHT + 50);
	outtextxy(110, GAME_HEIGHT + 20, "退出");
}

int checkButton(int mouseX, int mouseY)
{
	if (mouseX >= 10 && mouseX <= 70 && mouseY >= 410 && mouseY <= 450)
		return 1;
	else if (mouseX >= 100 && mouseX <= 150 && mouseY >= 410 && mouseY <= 450)
		return 2;
	else
		return -1;  //没选中	
}

void displayDog(TARGET tar)
{
	BeginBatchDraw();
	clearrectangle(3, GAME_HEIGHT - 48, WIDTH - 5, GAME_HEIGHT - 1);   //清空TARGET区
	setfillcolor(GREEN);
	fillellipse(tar.x + 2, tar.y + 5, tar.x + 50, tar.y + 30);
	EndBatchDraw();
}

void moveDog(TARGET &tar, int k)
{
	tar.x += k * 3;
}

void displayApple(APPLE apple)
{
	BeginBatchDraw();
	clearrectangle(1, 1, WIDTH - 2, GAME_HEIGHT - 49);   //清空苹果区
	setfillcolor(RED);
	fillellipse(apple.x, apple.y, apple.x + 50, apple.y + 30);
	EndBatchDraw();

}

void moveApple(APPLE &apple)
{
	apple.y += 3;
	if (apple.y > GAME_HEIGHT - 100) apple.y = 1;
}

void gameOver()
{
	exit(0);
}

*/


/*
int main()
{
	// 初始化图形窗口
	initgraph(640, 480);

	MOUSEMSG m;		// 定义鼠标消息

	while (true)
	{
		// 获取一条鼠标消息
		m = GetMouseMsg();

		switch (m.uMsg)
		{
		case WM_MOUSEMOVE:
			// 鼠标移动的时候画红色的小点
			putpixel(m.x, m.y, RED);
			break;

		case WM_LBUTTONDOWN:
			// 如果点左键的同时按下了 Ctrl 键
			if (m.mkCtrl)
				// 画一个大方块
				rectangle(m.x - 10, m.y - 10, m.x + 10, m.y + 10);
			else
				// 画一个小方块
				rectangle(m.x - 5, m.y - 5, m.x + 5, m.y + 5);
			break;

		case WM_RBUTTONUP:
			return 0;	// 按鼠标右键退出程序
		}
	}

	// 关闭图形窗口
	closegraph();
}*/